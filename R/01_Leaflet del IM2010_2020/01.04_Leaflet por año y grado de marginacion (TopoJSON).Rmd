---
title: "Leaflet por grados de marginaci칩n, 2010 - 2020"
subtitle: "Utilizando capas `TopoJSON`"
author: "Diana Villasana Ocampo"
output:
   html_document:
      highlight: tango
      theme: flatly
      toc: yes
      toc_depth: 4
      toc_float:
        collapsed: yes
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../../docs"
    )
  })
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 14px
}
h1.title {
  font-size: 35px;
  color: #1C3BA4;
}
h1 {
  color: #B6854D;
  font-size: 30px;
}
h2 {
  color: #172984;
  font-size: 25px;
}
h3 {
  color: #172984;
  font-size: 20px;
}
h4 {
  color: #174EC5;
  font-size: 18px;
}
h5 {
  color: #B6854D;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE,
                       eval = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
options(digits = 2)
``` 


```{r, echo = FALSE, results=FALSE, eval = TRUE}
require(dplyr)
require(forcats)
library(jsonlite)
require(sf)
require(sp)
require(stringr)
require(spdplyr)
require(htmltools)
require(leaflet)
require(htmlwidgets)
require(grDevices)
require(rgdal)
require(tibble)
require(RColorBrewer)
require(leafgl)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
require(rmapshaper)
require(geojsonio)
require(purrr)
#tempdir <- tempdir()
#unlink(tempdir, recursive = TRUE)
```

# Sistema de Informaci칩n Geogr치fica

El Instituto Nacional de Estad칤stica, Geograf칤a e Inform치tica (INEGI) tiene puestos a disposici칩n del p칰blico los shapefiles con los distintos niveles de informaci칩n geogr치fica. Estos archivos digitales se encuentran disponibles en el [`Marco Geoestad칤stico Nacional (MGN)`](https://www.inegi.org.mx/temas/mg/#Descargas), el cual es un sistema 칰nico y se presenta la divisi칩n del territorio nacional en diferentes niveles de desagregaci칩n para referir geogr치ficamente la informaci칩n estad칤stica de los censos y encuestas. Se integra al Sistema Nacional de Informaci칩n Estad칤stica y Geogr치fica (SNIEG).


## 칈ndice de marginaci칩n 2010 - 2020

Se cargan las bases de datos del 칤ndice de marginaci칩n a nivel estatal para los a침os `2010`, `2015` y `2020`. Las cuales se encuentran en formato `.RData`.   

**Bases de datos**   
- Nivel estatal    
- Nivel municipal   
- Nivel localidad   
- Nivel AGEB  
- Nivel Colonia    

**Base de datos** de los tres a침os se encuentran disponibles en la p치gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de M칠xico** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicaci칩n** [칈ndice De Marginaci칩n Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)     
    

```{r}
tablas <- c("2010", "2015", "2020")
for(i in tablas){
load(file = paste0(here::here(), "/Output/IME_", i, ".RData"))
}
```

## Shapefiles

A continuaci칩n, se leen y se transforman los shapefiles de las divisiones geogr치ficas de los estados de M칠xico correspondientes a los a침os `2020`, `2015` y `2010`.   

Utilizando la paqueter칤a `rgdal`, se definen los siguientes par치metros:      
 
- `readOGR`: Esta funci칩n se usa para leer shapefiles.   
- `dsn`: Especifica la ruta al directorio que contiene el shapefile.  
- `layer`: Especifica el nombre de la capa dentro del shapefile.  
- `encoding`: Especifica la codificaci칩n de los caracteres, en este caso, UTF-8.  
- `use_iconv`: Se usa para convertir la codificaci칩n si es necesario.  

Una vez cargados los sahpefiles, se transforman los sistemas de coordenadas:     

- `spTransform`: Esta funci칩n se usa para transformar las coordenadas del shapefile a un nuevo sistema de referencia.    
- `CRSobj`: Especifica el sistema de referencia de coordenadas de destino. En este caso, se usa el sistema de coordenadas geogr치ficas (latitud y longitud) basado en el elipsoide y `datum WGS84`.    


Estos pasos son cruciales para asegurar que los datos geoespaciales sean consistentes y compatibles para su uso en an치lisis geogr치ficos y visualizaci칩n, por ejemplo, en aplicaciones de Leaflet o cualquier otro software de mapeo.   

**Shapefile estados 2020**

```{r, eval = FALSE}
shape_estados_2020 <- readOGR(dsn = "D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos",
                               layer = "00ent",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2020 <- spTransform(shape_estados_2020, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2015**

```{r, eval = FALSE}
shape_estados_2015 <- readOGR(dsn ="D:/MGN/MGN Junio 2016/conjunto_de_datos", 
                               layer = "areas_geoestadisticas_estatales",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2015 <- spTransform(shape_estados_2015, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2010**

```{r, eval = FALSE}
shape_estados_2010 <- readOGR(dsn ="D:/MGN/MGN 2010 Version 4.3 (Jul-Dic 2009)/32_Entidades_Federativas", 
                               layer = "ESTADOS",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)
shape_estados_2010 <- spTransform(shape_estados_2010, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```



### ShapefilesDataFrame

Se cambian de `IDs` de los Features del Shapefile; de esta manera si se hace alguna manipulaci칩n al shapefile directamente los pol칤gonos tendr치n el ID de la clave de la entidad y conservar치n el orden. Adem치s de que es 칰til cuando se necesita asegurar que los IDs de las entidades geogr치ficas sean consistentes en longitud y formato para su posterior an치lisis o visualizaci칩n.     

- `sp::spChFIDs` cambia los IDs de las features del objeto Spatial.
- `str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0")`: Utiliza la funci칩n `str_pad()` para rellenar con ceros a la izquierda (si es necesario) para asegurarse de que cada ID tenga al menos 2 d칤gitos.     


```{r, eval = FALSE}
shape_estados_2020 <- shape_estados_2020 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2015 <- shape_estados_2015 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2015@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2010 <- shape_estados_2010 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2010@data$CVE_ENT, 2, "left", pad = "0"))
```



**Se insertan los datos del 칤ndice de marginaci칩n y se seccionan por grado de marginaci칩n**  

Este c칩digo realiza las siguientes acciones:

- Selecciona las columnas `CVE_ENT` y `GM_` del dataframe `DP2_`.   
- `stringr::str_trim(.$GM_, "both")`: Elimina los espacios en blanco al principio y al final de los valores en `GM_`.   
- `fct_relevel(..., c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))`: Reordena los niveles del factor `GM_` en el orden especificado.   
- `spdplyr:::left_join.Spatial()`,  Realiza un merge entre shape_estados_ y el dataframe modificado, usando `CVE_ENT` como clave.   

El resultado es un nuevo objeto Spatial (capa_estados_2020) que combina la geometr칤a de shape_estados_2020 con la informaci칩n adicional de `DP2_`, incluyendo la columna `GM_` con niveles reordenados.    



```{r, eval = FALSE}
capa_estados_2020 <- shape_estados_2020 %>%
                      spdplyr:::left_join.Spatial(., DP2_2020 %>% 
                                                      select(CVE_ENT, GM_2020) %>%  
                                                       mutate(GM_2020 = fct_relevel(stringr::str_trim(.$GM_2020, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2015 <- shape_estados_2015 %>%
                      spdplyr:::left_join.Spatial(., DP2_2015 %>% 
                                                      select(CVE_ENT, GM_2015) %>%  
                                                       mutate(GM_2015 = fct_relevel(stringr::str_trim(.$GM_2015, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2010 <- shape_estados_2010 %>%
                      spdplyr:::left_join.Spatial(., DP2_2010 %>% 
                                                      select(CVE_ENT, GM_2010) %>%  
                                                       mutate(GM_2010 = fct_relevel(stringr::str_trim(.$GM_2010, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 
```

### Capas de estados separados por el grado de marginaci칩n   
 
Se crean listas de capas de pol칤gonos filtrados por los grados de marginaci칩n para los a침os `2020`, `2015` y `2010`.   
- Las listas (`layers_estados_2020`, `layers_estados_2015`, `layers_estados_2010`), cada una con cinco elementos. Cada elemento es una capa de pol칤gonos filtrada por un grado de marginaci칩n espec칤fico.

```{r, eval = FALSE}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

layers_estados_2020 <- list()
layers_estados_2015 <- list()
layers_estados_2010 <- list()
for(i in 1:5){
  layers_estados_2020[[i]] <- capa_estados_2020  %>%
                               filter(GM_2020 == grados[i])
  layers_estados_2015[[i]] <- capa_estados_2015  %>%
                               filter(GM_2015 == grados[i])
  layers_estados_2010[[i]] <- capa_estados_2010  %>%
                               filter(GM_2010 == grados[i])
}
```


### geojson_json y topojson (Por grados de marginaci칩n)  

Se convierten las capas de pol칤gonos filtrados en objetos `GeoJSON`. Este proceso es 칰til para guardar las capas en un formato que puede ser f치cilmente utilizado para visualizaci칩n en la web o en aplicaciones de mapas interactivos.     

- `geojsonio::geojson_json`: Esta funci칩n convierte un objeto espacial a formato `GeoJSON`.  
- `geometry = "polygon"`: Especifica que las geometr칤as deben ser de tipo pol칤gono. Esto es adecuado para las entidades geogr치ficas de los estados que generalmente se representan como pol칤gonos.   
- `geojsonio::geojson_write`: Esta funci칩n escribe un objeto GeoJSON a un archivo.   


Esto es 칰til para guardar y compartir datos espaciales en un formato ampliamente compatible, como GeoJSON, que puede ser f치cilmente utilizado en aplicaciones web, sistemas de informaci칩n geogr치fica (SIG), y otros contextos de an치lisis y visualizaci칩n de datos geoespaciales.    


```{r, eval = FALSE}
capa_estados_2020_json <- list()
capa_estados_2015_json <- list()
capa_estados_2010_json <- list()
for(i in 1:5){
  capa_estados_2020_json[[i]] <- geojsonio::geojson_json(layers_estados_2020[[i]], geometry = "polygon")
  capa_estados_2015_json[[i]] <- geojsonio::geojson_json(layers_estados_2015[[i]], geometry = "polygon")
  capa_estados_2010_json[[i]] <- geojsonio::geojson_json(layers_estados_2010[[i]], geometry = "polygon")
}
```

### `geojsonio::geo2topo()`    

Se convierten los datos `GeoJSON` en datos `TopoJSON`, utilizando la funci칩n `geo2topo` del paquete `geojsonio`. Sin embargo, hay un peque침o ajuste que se debe hacer para que funcione correctamente.     

```{r, eval = FALSE}
capa_estados_2020_topojson <- list()
capa_estados_2015_topojson <- list()
capa_estados_2010_topojson <- list()
for(i in 1:5){
  capa_estados_2020_topojson[[i]] <- capa_estados_2020_json[[i]] %>% geojsonio::geo2topo()
  capa_estados_2015_topojson[[i]] <- capa_estados_2015_json[[i]] %>% geojsonio::geo2topo()
  capa_estados_2010_topojson[[i]] <- capa_estados_2010_json[[i]] %>% geojsonio::geo2topo()
}
```


### `topojson_write()`

La funci칩n `topojson_write()` del paquete `geojsonio` para escribir archivos `GeoJSON` a partir de los datos en las listas.  Este c칩digo permitir치 generar m칰ltiples archivos GeoJSON, uno para cada combinaci칩n de a침o (`2020`, `2015`, `2010`) y  dentro cada grado de marginaci칩n.   

```{r, eval = FALSE}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
for(i in 1:5){
 topojson_write(capa_estados_2020_topojson[[i]], 
                 geometry = "polygon",
                  file = paste0(here::here(), "/Output/estados_2020_", i, "_topojson.geojson"), )
 topojson_write(capa_estados_2015_topojson[[i]], 
                 geometry = "polygon", 
                  file = paste0(here::here(), "/Output/estados_2015_", i, "_topojson.geojson")) 
 topojson_write(capa_estados_2010_topojson[[i]], 
                 geometry = "polygon",
                  file = paste0(here::here(), "/Output/estados_2010_", i, "_topojson.geojson")) 
}
```

### `writeLines()`   

La funci칩n `writeLines` escribe las l칤neas de texto de un objeto en un archivo. En este caso, los objetos `TopoJSON`, generar m칰ltiples archivos uno para cada combinaci칩n de a침o (`2020`, `2015`, `2010`) y  dentro cada grado de marginaci칩n, donde se escriben directamente en archivos con formato .topojson.   

```{r, eval = FALSE}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

for(i in 1:5){
 writeLines(capa_estados_2020_topojson[[i]], paste0(here::here(), "/Output/estados_2020_", i, "_topojson.topojson")) 
 writeLines(capa_estados_2015_topojson[[i]], paste0(here::here(), "/Output/estados_2015_", i, "_topojson.topojson")) 
 writeLines(capa_estados_2010_topojson[[i]], paste0(here::here(), "/Output/estados_2010_", i, "_topojson.topojson")) 
}
```


La diferencia principal entre `GeoJSON` y `TopoJSON` radica en c칩mo representan y manejan la informaci칩n geoespacial:   

`GeoJSON`:   

- `Formato est치ndar`: `GeoJSON` es un formato de archivo est치ndar para representar datos geoespaciales en formato JSON.   
- `Geometr칤as simples`: Cada entidad geogr치fica (punto, l칤nea o pol칤gono) se representa directamente como coordenadas geogr치ficas (latitud y longitud).   
- `Tama침o del archivo`: `GeoJSON` tiende a ser m치s grande en tama침o de archivo en comparaci칩n con `TopoJSON` debido a la repetici칩n de coordenadas y la estructura directa de las geometr칤as.   

`TopoJSON`:    

- `Optimizaci칩n de datos`: `TopoJSON` es un formato m치s eficiente que optimiza la representaci칩n de datos geoespaciales.     
- `Topolog칤a compartida`: En lugar de representar cada geometr칤a directamente, `TopoJSON` utiliza una estructura de topolog칤a compartida. Esto significa que las fronteras comunes entre pol칤gonos se comparten, lo que reduce la redundancia de datos y, por lo tanto, el tama침o del archivo.       
- `Proceso de conversi칩n`: `TopoJSON` necesita ser convertido a `GeoJSON` o a otros formatos compatibles antes de ser utilizado en la mayor칤a de las aplicaciones GIS y bibliotecas de visualizaci칩n, incluyendo Leaflet.       


## GeoJson (Estados)   

游녢  Se vuelve a leer un archivo `GeoJSON ` y realizan algunas operaciones adicionales en el objeto espacial resultante:    

- `geojsonio::geojson_read()`: Esta funci칩n lee un archivo GeoJSON y lo convierte en un objeto espacial.    
- `what = "sp"`: Especifica que el resultado debe ser un objeto Spatial (de la clase `sp`) y no un formato lineal `.json`.   
- `sp::spChFIDs`: Esta funci칩n cambia los IDs de las features (FIDs) del objeto Spatial.     

```{r}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

shape_estados_2020 <- list()
shape_estados_2015 <- list()
shape_estados_2010 <- list()
for (i in 1:5){
  shape_estados_2020[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2020_", i, "_topojson.geojson"), 
                                                                      what = "sp", parse = TRUE, stringsAsFactors = TRUE) %>%
                                                         sp::spChFIDs(.,  str_pad(.@data$CVE_ENT, 2, "left", pad = "0")) %>%
                                                          mutate(id = str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))    
  shape_estados_2015[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2015_", i, "_topojson.geojson"), 
                                                                      what = "sp") %>%
                                                         sp::spChFIDs(.,  str_pad(.@data$CVE_ENT, 2, "left", pad = "0")) %>%
                                                          mutate(id = str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))    
  shape_estados_2010[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2010_", i, "_topojson.geojson"), 
                                                                      what = "sp") %>% 
                                                         sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0")) %>%
                                                          mutate(id = str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))    
}

shape_estados <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2020_json.geojson"), 
                                         what = "sp") %>%
                                        sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
```


## Leaflet 

- `GeoJSON en Leaflet`: Leaflet puede manejar directamente archivos GeoJSON para la visualizaci칩n de datos geoespaciales. Es compatible de manera nativa con GeoJSON, lo que significa que puedes agregar capas de GeoJSON directamente al mapa Leaflet usando funciones como `addGeoJSON`.      

- `TopoJSON en Leaflet`: Aunque Leaflet no puede manejar directamente archivos TopoJSON, puedes convertir archivos TopoJSON a GeoJSON utilizando herramientas como `geojsonio::geojson_read()` en R antes de cargar los datos en Leaflet. Esto permite aprovechar las ventajas de tama침o y rendimiento de TopoJSON mientras se trabaja con Leaflet.      

### Paleta de colores  

Se crea una paleta de colores que se usar치 para mapear valores de una variable categ칩rica a colores en una visualizaci칩n de Leaflet.  

```{r}
paleta <- c("#13322B", #Muy alto
            "#086953", #Alto 
            "#4C9562", #Medio
            "#D1BB9E", #Bajo
            "#C3BA6D") # Muy bajo

            
## Paleta de colores                         
mypalette <- leaflet::colorFactor(palette = paleta, 
                                            domain = forcats::fct_relevel(DP2_2020$GM_2020, c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")), 
                                            na.color = "transparent")
```


### T칤tulo 

Se define el estilo y el contenido de un t칤tulo para un mapa Leaflet utilizando `HTML` y `CSS` dentro de `R`.    

- `tags$style(HTML("..."))`: Esta funci칩n permite incluir estilos CSS en el documento.   
- `.leaflet-control.map-title`: Define una clase CSS que se aplicar치 al t칤tulo del mapa.  
- `tags$div(...)`: Crea un contenedor div en el cual se coloca el t칤tulo del mapa.  
- `tag.map.title`: Aplica los estilos definidos anteriormente a este contenedor div.  

```{r}
# Estructura del t칤tulo
tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px; 
    padding-right: 10px; 
    background: rgba(255,255,255,0.75);
    font-weight: bold;
    font-size: 28px;
  }
 ")) 

# Nota de p치gina
title <- tags$div(
  tag.map.title, HTML("Fuentes:Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci칩n y Vivienda 2020.")
)  
```

### L칤mites del mapa    

Se calcula el cuadro delimitador que contiene las coordenadas de los l칤mitesde un objeto espacial utilizando la funci칩n `st_bbox()` de la librer칤a `sf`.     

- `xmin`: La coordenada m칤nima en el eje x (longitud m칤nima).   
- `ymin`: La coordenada m칤nima en el eje y (latitud m칤nima).   
- `xmax`: La coordenada m치xima en el eje x (longitud m치xima).   
- `ymax`: La coordenada m치xima en el eje y (latitud m치xima).     

```{r}
bounding_box <- st_bbox(shape_estados)
bounding_box 
#bounding_box <- c(-118.4, 14.5, -86.7, 32.7)
```
### Leaflet estructura {.tabset .tabset-fade .tabset-pills}   

#### Opci칩n 1   

`TopoJSON en Leaflet`: Aunque Leaflet no puede manejar directamente archivos TopoJSON, se pueden convertir archivos TopoJSON a GeoJSON utilizando herramientas como `geojsonio::geojson_read()` antes de cargar los datos en Leaflet. Esto permite aprovechar las ventajas de tama침o y rendimiento de `TopoJSON` mientras se trabaja con Leaflet.  Es perfectamente compatible con la funci칩n `addPolygons()`, en este caso los datos que se encuentran en los objetos `shape_estados_` contiene los datos espaciales cargados desde el archivo TopoJSON.         

##### Se definen los a침os y los grados de marginaci칩n    

- `years`: Un vector que contiene los a침os para los que tenemos datos de shapefiles.  
- `grados`: Un vector que contiene los niveles de marginaci칩n.  

Se asigna a la lista `shape_estados` con una estrcutura de listas de data frames geoespaciales correspondientes a diferentes a침os y grados de marginaci칩n. Para cada data frame de los `SpatiaPolygonsDataFrame`, se le a침aden varias columnas nuevas: una con IDs 칰nicos, otra con el a침o correspondiente, otra con una combinaci칩n de ID y a침o.   

**Transformaci칩n de Coordenadas**    

Se asegura que cada shapefile tenga un sistema de coordenadas uniforme. Utilizando la funci칩n `map2()` de `purrr` para iterar sobre las listas anidadas de shapefiles y sus a침os correspondientes. Dentro de la funci칩n anidada, se itera sobre cada shapefile y sus grados correspondientes, asignandoles el sistema de coordenadas `CRS "+init=epsg:4326" `a cada shapefile y se transforma a este sistema de coordenadas.      

**Vectores y funci칩nes**    
- `years`: Se define un vector con los a침os `2020`, `2015` y `2010`.     
- `generate_ids`: Es una funci칩n que genera una secuencia de n칰meros que los convierte en caracteres y les agrega ceros a la izquierda para que tengan al menos dos d칤gitos.      - `map2(shape_estados, years, ...)`: La funci칩n en conjunto transforma los shapefiles de cada a침o y grado, generando IDs 칰nicos y a침adiendo columnas adicionales que ayudan a identificar cada observaci칩n con un ID y un a침o espec칤ficos.     

Se generan algunas variables que van a ayudar a integrar los a침os y los grados de marginaci칩n dentro del leaflet de manera din치mica.      

- `ID`: Se genera IDs 칰nicos para cada entidad, utilizando la funci칩n `generate_ids`. Por ejemplo, para el primer a침o (2020), generar치 IDs del 1 al 32; para el segundo a침o (2015), del 33 al 64; y para el tercer a침o (2010), del 65 al 96. Tomando en cuenta que cada a침o, se encuentra estructurado por un grupo de listas que corresponden a los diferentes grados de marginaci칩n.          
- `ANIO`: Agrega una columna con el a침o correspondiente (`2020`, `2015` o `2010`).     
- `id_year`: Crea una columna que combina el ID generado con el a침o correspondiente, por ejemplo, 0102020, 0202020, etc.   


```{r}
# Define los grados y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

shape_estados <- NULL
shape_estados <- list(shape_estados_2020, shape_estados_2015, shape_estados_2010)

# Aplicar la transformaci칩n a cada elemento en las listas anidadas usando map2
shape_estados <- map2(shape_estados, years, function(shape_files, year) {
                       map2(shape_files, grados, function(shape_file, grado) {
                             proj4string(shape_file) <- CRS("+init=epsg:4326")
                             shape_file  = spTransform(shape_file, CRS("+init=epsg:4326"))
                             shape_file
                      })
})

#shape_estados_coords <- map2(shape_estados, years, function(shape_files, year) {
#                         map2(shape_files, grados, function(shape_file, grado) {
#                           # Extraer y renombrar coordenadas
#                           shape_file@polygons <- lapply(shape_file@polygons, function(polygon) {
#                             polygon@Polygons <- lapply(polygon@Polygons, function(sub_polygon) {
#                               coords <- as.data.frame(sub_polygon@coords)
#                               colnames(coords) <- c("lng", "lat")
#                               sub_polygon@coords <- as.matrix(coords)
#                               sub_polygon
#                             })
#                             polygon
#                           })
#                           
#                           shape_file
#                         })
#})

## Funci칩n para generar IDs:  
generate_ids <- function(start, end) {
                  str_pad(as.character(seq(start, end)), 2, "left", pad = "0")
}

# Aplicar la transformaci칩n a cada lista de shape_estados
start_id <- 1
shape_estados <- map2(shape_estados, years, function(shape_files, year) {
                       shape_files <- map2(shape_files, grados, function(shape_file, grado) {
                                            if (is.data.frame(shape_file@data)) {
                                                 end_id <- start_id + nrow(shape_file) - 1
                                                 shape_file <- shape_file %>%
                                                                mutate(ID = generate_ids(start_id, end_id),
                                                                       ANIO = year,
                                                                       id_year = paste0(generate_ids(start_id, end_id), year))
                                                 start_id <<- end_id + 1
                                                }
                                       shape_file
                                       })
                       shape_files
  }
)
```

##### Se define una funci칩n para a침adir capas de pol칤gonos   

Se define una funci칩n llamada `addPolygonLayer`, la cual a침ade una capa de pol칤gonos a un mapa de Leaflet. Se tienen que especificar los argumentos:   

- `map`: El objeto de mapa de Leaflet al que se le a침adir치 la nueva capa de pol칤gonos.   
- `data`: Los datos que contienen la informaci칩n geogr치fica de los pol칤gonos.   
- `year`: A침o asociado con los datos de los pol칤gonos, usado para agrupar.    
- `grado`: Grado asociado con los datos de los pol칤gonos, tambi칠n usado para agrupar.   
- `paleta`: Paleta de colores que se usar치 para rellenar los pol칤gonos.
- `id`: Es el identificador 칰nico para esta capa de pol칤gonos en el mapa. Puede ser 칰til para identificar y manipular espec칤ficamente esta capa en operaciones posteriores.    

```{r}
# Define una funci칩n para a침adir capas de pol칤gonos
addPolygonLayer <- function(map, data, year, grado, paleta, id) {
                            map <- map %>%
                                    addPolygons(data = data,
                                                 fillColor = paleta,
                                                  fillOpacity = 0.8,
                                                   stroke = TRUE,
                                                    weight = 1,
                                                     dashArray = "1",
                                                      opacity = 1.3,
                                                       color = "#DBDBDB",  # line colour 
                                                        highlight = highlightOptions(weight = 2,
                                                                                     color = "red", # Color de selecci칩n
                                                                                     dashArray = "",
                                                                                     fillOpacity = 0.6,
                                                                                     bringToFront = TRUE),
                                                         group = grado,
                                                          layerId = id
                                                )
                             return(map)
}
```


#####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor. 

```{r}
# Crear el mapa inicial
map  <- leaflet() %>%
         addTiles() %>%
          setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
           setMaxBounds(lng1 = bounding_box[1],
                        lat1 = bounding_box[2],
                        lng2 = bounding_box[3],
                        lat2 = bounding_box[4]) %>%
            addProviderTiles(providers$OpenStreetMap, options = providerTileOptions(minZoom = 5, maxZoom = 5))
```


##### Funci칩n `addPolygonLayer()`   

Se construye din치micamente un mapa interactivo que muestra diferentes capas de pol칤gonos para los a침os `2020`, `2015` y `2010`, utilizando funciones y enfoques que permiten manejar de manera flexible los datos geoespaciales. Cada iteraci칩n del bucle a침ade una nueva capa de pol칤gonos al mapa `map`, lo que permite visualizar los datos geoespaciales para cada a침o de manera superpuesta en el mismo mapa interactivo. Se recorren todas las combinaciones posibles de a침os (`years`), y se a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La funci칩n contiene, los shape_estados que son los datos geogr치ficos organizados por a침o y grado, la paleta de colores correspondiente para cada grado y el ID unico de cada observaci칩n correspondiente a cada a침o.  

```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

# A침adir capas de pol칤gonos para cada a침o
for (i in seq_along(years)) {
  for(j in seq_along(grados)){
           map <- addPolygonLayer(map,
                                  data = shape_estados[[i]][[grados[j]]], 
                                  year = ~ANIO, 
                                  grado = ~get(paste0("GM_", years[i])), 
                                  paleta = paleta[j], 
                                  id = ~id_year
                                  )
  }
}
```


##### Se a침ade la leyenda y control de capas    

Se a침aden los controles adicionales y una leyenda al mapa de Leaflet. Permitiendo al usuario explorar diferentes capas de datos y visualizar informaci칩n geoespacial de manera organizada y comprensible.     

- `addLayersControl()`: Agrega un control de capas al mapa para permitir al usuario seleccionar qu칠 capas base u overlay (superpuestas) desea visualizar.   
- `overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")`: Define los grupos de capas superpuestas que se mostrar치n en el control de capas. En este caso, parecen ser categor칤as de grado de marginaci칩n.   
- `baseGroups = c("2020", "2015", "2010")`: Define los grupos de capas base que se mostrar치n en el control de capas. Estos podr칤an ser los a침os para los cuales se est치n visualizando datos.    
- `options = layersControlOptions(collapsed = FALSE)`:  Especifica las opciones del control de capas. collapsed = FALSE significa que el control de capas estar치 expandido por defecto, mostrando todas las opciones disponibles sin necesidad de expandirlo manualmente.         

```{r}
map <- map %>%
        addControl(title, position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                    labels = grados,
                    title = stringr::str_wrap("Grado de marginaci칩n", 15), 
                    opacity = 0.7) %>%
          addLayersControl(
           overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
            baseGroups = c("2020", "2015", "2010"), 
             options = layersControlOptions(collapsed = FALSE))
```

##### Se configura el control de capas     

El bloque de este c칩digo JavaScript se utiliza junto con el paquete `htmlwidgets`  para controlar la visibilidad y la interactividad de las capas en un mapa Leaflet. Este c칩digo JavaScript personalizado mejora la funcionalidad de un mapa Leaflet al permitir que el usuario controle din치micamente qu칠 capas base y superpuestas est치n visibles en el mapa. Al cambiar la capa base o a침adir capas superpuestas, las capas que no corresponden se ocultan autom치ticamente, manteniendo as칤 una visualizaci칩n clara y organizada de los datos geoespaciales.     

Los eventos `baselayerchange`, `overlayadd`, `overlayremove`: A침aden eventos para actualizar las capas visibles cuando el usuario cambia la capa base o a침ade/remueve capas superpuestas.   

- `baselayerchange`: Este evento se activa cuando el usuario cambia la capa base del mapa.
- `overlayadd`: Este evento se activa cuando se a침ade una capa superpuesta al mapa.

```{r}
map <- map %>%
        htmlwidgets::onRender("
          function(el, x) {
            var myMap = this;
            var baseLayer = '2020';
            myMap.eachLayer(function(layer) {
              var id = layer.options.layerId;
              if (id) {
                if (!id.endsWith(baseLayer)) {
                  layer.getElement().style.display = 'none';
                }
              }
            });
      
            myMap.on('baselayerchange', function(e) {
              baseLayer = e.name;
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                    layer.closePopup();
                  } 
                  else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
      
            myMap.on('overlayadd', function(e) {
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                  } else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
          }")
map
```


Se genera un Widget Interactivo con la funci칩n `saveWidget()`.     
  
**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).    
 
```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/img/map_2010_2020.html"), selfcontained = TRUE)
map <- map %>% 
        mapshot(url = paste0(here::here(), "/map_2010_2020.html"))
```


#### Opci칩n 2   

`TopoJSON en Leaflet`:  Se leen archivos `TopoJSON` y almacenarlos en listas anidadas seg칰n los a침os y grados especificados. La funci칩n `readLines` se utiliza para leer el contenido de los archivos `TopoJSON` y almacenar cada l칤nea del archivo como un elemento en un vector de caracteres dentro de las listas correspondientes a cada a침o y grado. Esto facilita la organizaci칩n y el acceso a los datos le칤dos en un formato estructurado.    

```{r}
# Define los grados y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

shape_estados_2020 <- list()
shape_estados_2015 <- list()
shape_estados_2010 <- list()
for(i in 1:5){
 shape_estados_2020[[paste0(grados[i])]] <- readLines(paste0(here::here(), "/Output/estados_2020_", i, "_topojson.topojson")) %>% 
                                              paste(collapse = "\n") 
 shape_estados_2015[[paste0(grados[i])]] <- readLines(paste0(here::here(), "/Output/estados_2015_", i, "_topojson.topojson")) %>% 
                                              paste(collapse = "\n") 
 shape_estados_2010[[paste0(grados[i])]] <- readLines(paste0(here::here(), "/Output/estados_2010_", i, "_topojson.topojson")) %>% 
                                              paste(collapse = "\n") 
}
```


##### Se definen los a침os y los grados de marginaci칩n    

- `years`: Un vector que contiene los a침os para los que tenemos datos de shapefiles.  
- `grados`: Un vector que contiene los niveles de marginaci칩n.  

Se asigna a la lista `shape_estados` los datos de shapefile correspondientes a cada a침o, el cual a su vez cada lista contiene a los niveles de marginaci칩n.     

```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")
grados <-  c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

## Lista de shapefiles de todos los a침os
shape_estados <- NULL
shape_estados <- list(shape_estados_2020, shape_estados_2015, shape_estados_2010)
```

**Transformaci칩n y Manipulaci칩n de los Datos**:    

- Las listas de datos se transforman en objetos `JSON` utilizando `fromJSON()`.     
- Se generan IDs 칰nicos y se a침aden propiedades `ID`, `ANIO` y `id_year` a cada geometr칤a.      
- La variable start_id se utiliza para mantener un conteo acumulativo de los IDs generados.     

```{r}
# lista de TopoJSONs:
shape_estados <- map(seq_along(years), function(year) {
                   map(grados, function(grado) {
                                fromJSON(get(paste0("shape_estados"))[[year]][[grado]], simplifyVector = FALSE)
                      })
                    })

# Funci칩n para generar IDs:   
generate_ids <- function(start, end) {
    str_pad(as.character(seq(start, end)), 2, "left", pad = "0")
}

# Aplicar transformaciones a las propiedades de cada geometr칤a
start_id <- 1
shape_estados <- map2(shape_estados, years, function(shape_files, year) {
                    map2(shape_files, seq_along(grados), function(shape_file, grado_idx) {
                          geometries <- shape_file$objects$foo$geometries
                            geometries <- map(geometries, function(geom) {
                                            properties <- geom$properties
                                              if (!is.null(properties) && length(properties) > 0) {
                                                end_id <- start_id + length(properties$CVE_ENT) - 1
                                                properties[["ID"]] <- generate_ids(start_id, end_id)
                                                properties[["ANIO"]] <- year
                                                properties[["id_year"]] <- paste0(generate_ids(start_id, end_id), year)
                                                geom$properties <- properties
                                                start_id <<- end_id + 1
                                                  }
                                                geom
                                              })
                          shape_file$objects$foo$geometries <- geometries
                          shape_file
                    })
})
```

**Estilos de la geometr칤a**:     

- Se define una paleta de colores correspondiente a los diferentes grados de marginaci칩n.    
- Los estilos se aplican a cada shapefile, incluyendo la propiedad `layerId` que utiliza el valor de id_year.     

```{r}
paleta <- c("#13322B", #Muy alto
            "#086953", #Alto 
            "#4C9562", #Medio
            "#D1BB9E", #Bajo
            "#C3BA6D") # Muy bajo

shape_estados <- map2(shape_estados, years, function(shape_files, year) {
                      map2(shape_files, seq_along(grados), function(shape_file, grado_idx) {
                        # Obtener id_year para el estilo
                        id_year <- shape_file$objects$foo$geometries[[1]]$properties$id_year
                        
                        shape_file$style = list(fillColor = paleta[grado_idx],
                                                fillOpacity = 0.8,
                                                stroke = TRUE,
                                                weight = 1,
                                                dashArray = "1",
                                                opacity = 1,
                                                color = "#D4D0BD",
                                                layerId = id_year
                                                )
                        shape_file
                        })
                      })
```

##### Se define una funci칩n para a침adir capas de pol칤gonos   

Se define una funci칩n llamada `addPolygonLayer`, la cual a침ade una capa de pol칤gonos a un mapa de Leaflet. Se tienen que especificar los argumentos:   

- `map`: El objeto de mapa de Leaflet al que se le a침adir치 la nueva capa de pol칤gonos.   
- `data`: Los datos que contienen la informaci칩n geogr치fica de los pol칤gonos.   
- `year`: A침o asociado con los datos de los pol칤gonos, usado para agrupar.    
- `grado`: Grado asociado con los datos de los pol칤gonos, tambi칠n usado para agrupar.   

```{r}
# Define una funci칩n para a침adir capas de pol칤gonos
addPolygonLayer <- function(map, data, year, grado) {
                             map <- map %>%
                                     addTopoJSON(data,
                                                  group = grado
                                                )
                             return(map)
}
```

#####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor.    

```{r}
# Crear el mapa inicial
map <- leaflet(options = leafletOptions(minZoom = 5, maxZoom = 5, zoomControl = FALSE)) %>%
        addTiles() %>%
         setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
          setMaxBounds(lng1 = bounding_box[1],
                       lat1 = bounding_box[2],
                       lng2 = bounding_box[3],
                       lat2 = bounding_box[4]) %>%
           addProviderTiles(providers$OpenStreetMap, options = providerTileOptions(minZoom = 5, maxZoom = 5)) 
```


##### Funci칩n `addPolygonLayer()`   

Se a침aden las capas de pol칤gonos al mapa de Leaflet para cada combinaci칩n de a침o y grado. Se recorren todas las combinaciones posibles de a침os (`years`) y grados (`grados`), y para cada combinaci칩n, a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La lista shape_estados contiene los datos geogr치ficos organizados por a침o y grado, y la lista paleta proporciona la paleta de colores correspondiente para cada grado.    


```{r}
# A침adir capas de pol칤gonos para cada a침o
for (i in seq_along(years)) {
  for(j in seq_along(grados)){
           map <- addPolygonLayer(map, 
                                   data = shape_estados[[i]][[j]], 
                                    year = years[i], 
                                     grado = grados[j]
                                  )
  }
}
```

##### Se a침ade la leyenda y control de capas    

Se a침aden los controles adicionales y una leyenda al mapa de Leaflet. Permitiendo al usuario explorar diferentes capas de datos y visualizar informaci칩n geoespacial de manera organizada y comprensible.     

- `addLayersControl()`: Agrega un control de capas al mapa para permitir al usuario seleccionar qu칠 capas base u overlay (superpuestas) desea visualizar.   
- `overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")`: Define los grupos de capas superpuestas que se mostrar치n en el control de capas. En este caso, parecen ser categor칤as de grado de marginaci칩n.   
- `baseGroups = c("2020", "2015", "2010")`: Define los grupos de capas base que se mostrar치n en el control de capas. Estos podr칤an ser los a침os para los cuales se est치n visualizando datos.    
- `options = layersControlOptions(collapsed = FALSE)`:  Especifica las opciones del control de capas. collapsed = FALSE significa que el control de capas estar치 expandido por defecto, mostrando todas las opciones disponibles sin necesidad de expandirlo manualmente.         

```{r}
map <- map %>%
        addControl(title, position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                    labels = grados,
                    title = stringr::str_wrap("Grado de marginaci칩n", 15), 
                    opacity = 0.7) %>%
          addLayersControl(
           overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
            baseGroups = c("2020", "2015", "2010"), 
             options = layersControlOptions(collapsed = FALSE))
```


##### Se configura el control de capas     

El bloque de este c칩digo JavaScript se utiliza junto con el paquete `htmlwidgets`  para controlar la visibilidad y la interactividad de las capas en un mapa Leaflet. Este c칩digo JavaScript personalizado mejora la funcionalidad de un mapa Leaflet al permitir que el usuario controle din치micamente qu칠 capas base y superpuestas est치n visibles en el mapa. Al cambiar la capa base o a침adir capas superpuestas, las capas que no corresponden se ocultan autom치ticamente, manteniendo as칤 una visualizaci칩n clara y organizada de los datos geoespaciales.     

Los eventos `baselayerchange`, `overlayadd`, `overlayremove`: A침aden eventos para actualizar las capas visibles cuando el usuario cambia la capa base o a침ade/remueve capas superpuestas.   

- `baselayerchange`: Este evento se activa cuando el usuario cambia la capa base del mapa.
- `overlayadd`: Este evento se activa cuando se a침ade una capa superpuesta al mapa.

```{r}
map <- map %>%
        htmlwidgets::onRender("
          function(el, x) {
            var myMap = this;
            var baseLayer = '2020';
            myMap.eachLayer(function(layer) {
              var id = layer.options.layerId;
              if (id) {
                if (!id.endsWith(baseLayer)) {
                  layer.getElement().style.display = 'none';
                }
              }
            });
      
            myMap.on('baselayerchange', function(e) {
              baseLayer = e.name;
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                    layer.closePopup();
                  } 
                  else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
      
            myMap.on('overlayadd', function(e) {
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                  } else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
          }")
```


Se genera un Widget Interactivo con la funci칩n `saveWidget()`, 
  

**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).    

```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/index.html"), selfcontained = TRUE)

map <- map %>% 
        mapshot(url = paste0(here::here(), "/index.html")) 
```

 
```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/img/map_2010_2020.html"), selfcontained = TRUE)
map <- map %>% 
        mapshot(url = paste0(here::here(), "/map_2010_2020.html"))
```


# Librer칤as

**Librer칤as que se usaron en el trabajo**

```{r, echo = FALSE, eval = TRUE}
sesion_info <- devtools::session_info()
knitr::kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
 kableExtra::kable_classic(full_width = TRUE, html_font = 'Montserrat Medium', font_size = 10) 
```


<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Licence" style="border-width:0"/></a><br />This work by [**Diana Villasana Ocampo**]{xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"} is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.  