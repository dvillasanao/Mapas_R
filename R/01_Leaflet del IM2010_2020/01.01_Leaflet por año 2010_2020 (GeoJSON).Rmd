---
title: "Leaflet a nivel estatal, 2010 - 2020"
subtitle: "Utilizando capas `geojson`"
author: "Diana Villasana Ocampo"
output:
   html_document:
      highlight: tango
      theme: flatly
      toc: yes
      toc_depth: 4
      toc_float:
        collapsed: yes
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../../docs"
    )
  })
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 14px
}
h1.title {
  font-size: 40px;
  color: #1C3BA4;
}
h1 {
  color: #B6854D;
}
h2 {
  color: #172984;
}
h3 {
  color: #172984;
}
h5 {
  color: #B6854D;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE, #cache.extra = 
                       eval = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
options(digits = 2)
``` 


```{r, echo = FALSE, results=FALSE, eval = TRUE}
require(dplyr)
require(forcats)
require(sp)
require(stringr)
require(spdplyr)
require(htmltools)
require(leaflet)
require(htmlwidgets)
require(grDevices)
require(rgdal)
require(tibble)
require(sf)
require(RColorBrewer)
require(leafgl)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
#tempdir <- tempdir()
#unlink(tempdir, recursive = TRUE)
```


# Sistema de Informaci칩n Geogr치fica

El Instituto Nacional de Estad칤stica, Geograf칤a e Inform치tica (INEGI) tiene puestos a disposici칩n del p칰blico los shapefiles con los distintos niveles de informaci칩n geogr치fica. Estos archivos digitales se encuentran disponibles en el [`Marco Geoestad칤stico Nacional (MGN)`](https://www.inegi.org.mx/temas/mg/#Descargas), el cual es un sistema 칰nico y se presenta la divisi칩n del territorio nacional en diferentes niveles de desagregaci칩n para referir geogr치ficamente la informaci칩n estad칤stica de los censos y encuestas. Se integra al Sistema Nacional de Informaci칩n Estad칤stica y Geogr치fica (SNIEG).


## 칈ndice de marginaci칩n 2010 - 2020

Se cargan las bases de datos del 칤ndice de marginaci칩n a nivel estatal para los a침os `2010`, `2015` y `2020`. Las cuales se encuentran en formato `.RData`.   

**Bases de datos**   
- Nivel estatal    
- Nivel municipal   
- Nivel localidad   
- Nivel AGEB  
- Nivel Colonia    

**Base de datos** de los tres a침os se encuentran disponibles en la p치gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de M칠xico** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicaci칩n** [칈ndice De Marginaci칩n Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)     


```{r}
tablas <- c("2010", "2015", "2020")
for(i in tablas){
load(file = paste0(here::here(), "/Output/IME_", i, ".RData"))
}
```

## Shapefiles

A continuaci칩n, se leen y se transforman los shapefiles de las divisiones geogr치ficas de los estados de M칠xico correspondientes a los a침os `2020`, `2015` y `2010`.   

Utilizando la paqueter칤a `rgdal`, se definen los siguientes par치metros:      
 
- `readOGR`: Esta funci칩n se usa para leer shapefiles.   
- `dsn`: Especifica la ruta al directorio que contiene el shapefile.  
- `layer`: Especifica el nombre de la capa dentro del shapefile.  
- `encoding`: Especifica la codificaci칩n de los caracteres, en este caso, UTF-8.  
- `use_iconv`: Se usa para convertir la codificaci칩n si es necesario.  

Una vez cargados los sahpefiles, se transforman los sistemas de coordenadas:     

- `spTransform`: Esta funci칩n se usa para transformar las coordenadas del shapefile a un nuevo sistema de referencia.    
- `CRSobj`: Especifica el sistema de referencia de coordenadas de destino. En este caso, se usa el sistema de coordenadas geogr치ficas (latitud y longitud) basado en el elipsoide y `datum WGS84`.    


Estos pasos son cruciales para asegurar que los datos geoespaciales sean consistentes y compatibles para su uso en an치lisis geogr치ficos y visualizaci칩n, por ejemplo, en aplicaciones de Leaflet o cualquier otro software de mapeo.   


**Shapefile estados 2020**

```{r, eval = FALSE}
shape_estados_2020 <- readOGR(dsn = "D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos",
                               layer = "00ent",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2020 <- spTransform(shape_estados_2020, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2015**

```{r, eval = FALSE}
shape_estados_2015 <- readOGR(dsn ="D:/MGN/MGN Junio 2016/conjunto_de_datos", 
                               layer = "areas_geoestadisticas_estatales",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2015 <- spTransform(shape_estados_2015, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2010**

```{r, eval = FALSE}
shape_estados_2010 <- readOGR(dsn ="D:/MGN/MGN 2010 Version 4.3 (Jul-Dic 2009)/32_Entidades_Federativas", 
                               layer = "ESTADOS",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)
shape_estados_2010 <- spTransform(shape_estados_2010, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```


  
### ShapefilesDataFrame   

Se cambian de `IDs` de los Features del Shapefile; de esta manera si se hace alguna manipulaci칩n al shapefile directamente los pol칤gonos tendr치n el ID de la clave de la entidad y conservar치n el orden. Adem치s de que es 칰til cuando se necesita asegurar que los IDs de las entidades geogr치ficas sean consistentes en longitud y formato para su posterior an치lisis o visualizaci칩n.     

- `sp::spChFIDs` cambia los IDs de las features del objeto Spatial.
- `str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0")`: Utiliza la funci칩n `str_pad()` para rellenar con ceros a la izquierda (si es necesario) para asegurarse de que cada ID tenga al menos 2 d칤gitos.     


```{r, eval = FALSE}
shape_estados_2020 <- shape_estados_2020 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2015 <- shape_estados_2015 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2015@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2010 <- shape_estados_2010 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2010@data$CVE_ENT, 2, "left", pad = "0"))
```



**Se insertan los datos del 칤ndice de marginaci칩n y se seccionan por grado de marginaci칩n**  

Este c칩digo realiza las siguientes acciones:

- Selecciona las columnas `CVE_ENT` y `GM_` del dataframe `DP2_`.   
- `stringr::str_trim(.$GM_, "both")`: Elimina los espacios en blanco al principio y al final de los valores en `GM_`.   
- `fct_relevel(..., c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))`: Reordena los niveles del factor `GM_` en el orden especificado.   
- `spdplyr:::left_join.Spatial()`,  Realiza un merge entre shape_estados_ y el dataframe modificado, usando `CVE_ENT` como clave.   

El resultado es un nuevo objeto Spatial (capa_estados_2020) que combina la geometr칤a de shape_estados_2020 con la informaci칩n adicional de `DP2_`, incluyendo la columna `GM_` con niveles reordenados.        

```{r, eval = FALSE}
capa_estados_2020 <- shape_estados_2020 %>%
                      spdplyr:::left_join.Spatial(., DP2_2020 %>% 
                                                      select(CVE_ENT, GM_2020) %>%  
                                                       mutate(GM_2020 = fct_relevel(stringr::str_trim(.$GM_2020, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2015 <- shape_estados_2015 %>%
                      spdplyr:::left_join.Spatial(., DP2_2015 %>% 
                                                      select(CVE_ENT, GM_2015) %>%  
                                                       mutate(GM_2015 = fct_relevel(stringr::str_trim(.$GM_2015, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2010 <- shape_estados_2010 %>%
                      spdplyr:::left_join.Spatial(., DP2_2010 %>% 
                                                      select(CVE_ENT, GM_2010) %>%  
                                                       mutate(GM_2010 = fct_relevel(stringr::str_trim(.$GM_2010, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 
```

### `geojson_json()`   

Se convierte el objeto espacial `capa_estados_` a formato `GeoJSON` y luego escribe el resultado en un archivo.   
- `geojsonio::geojson_json`: Esta funci칩n convierte un objeto espacial a formato `GeoJSON`.  
- `geometry = "polygon"`: Especifica que las geometr칤as deben ser de tipo pol칤gono. Esto es adecuado para las entidades geogr치ficas de los estados que generalmente se representan como pol칤gonos.   
- `geojsonio::geojson_write`: Esta funci칩n escribe un objeto GeoJSON a un archivo.   


Esto es 칰til para guardar y compartir datos espaciales en un formato ampliamente compatible, como GeoJSON, que puede ser f치cilmente utilizado en aplicaciones web, sistemas de informaci칩n geogr치fica (SIG), y otros contextos de an치lisis y visualizaci칩n de datos geoespaciales.   

```{r, eval = FALSE}
require(geojsonio)
capa_estados_2020_json <- geojsonio::geojson_json(capa_estados_2020, geometry = "polygon")
capa_estados_2015_json <- geojsonio::geojson_json(capa_estados_2015, geometry = "polygon")
capa_estados_2010_json <- geojsonio::geojson_json(capa_estados_2010, geometry = "polygon")

# Se guarda en un archivo geojson 
capa_estados_2020_json <- geojsonio::geojson_json(capa_estados_2020, geometry = "polygon")
geojsonio::geojson_write(capa_estados_2020_json, file = paste0(here::here(), "/Output/estados_2020_json.geojson"))
geojsonio::geojson_write(capa_estados_2015_json, file = paste0(here::here(), "/Output/estados_2015_json.geojson"))
geojsonio::geojson_write(capa_estados_2010_json, file = paste0(here::here(), "/Output/estados_2010_json.geojson"))

#capa_estados_mapshaper <- rmapshaper::ms_simplify(capa_estados_json, keep = 0.5, weighting = 0)
#capa_estados_topojson <- capa_estados_mapshaper %>% geojsonio::geo2topo()
```


## GeoJson (Estados)  

游녢 Se vuelve a leer un archivo `GeoJSON ` y realizan algunas operaciones adicionales en el objeto espacial resultante:   

- `geojsonio::geojson_read()`: Esta funci칩n lee un archivo GeoJSON y lo convierte en un objeto espacial.   
- `what = "sp"`: Especifica que el resultado debe ser un objeto Spatial (de la clase sp) y no un formato lineal `.json`.  
- `sp::spChFIDs`: Esta funci칩n cambia los IDs de las features (FIDs) del objeto Spatial.     

```{r}
shape_estados_2020 <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2020_json.geojson"), what = "sp") %>%
                                  sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
shape_estados_2015 <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2015_json.geojson"), what = "sp") %>%
                                  sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
shape_estados_2010 <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2010_json.geojson"), what = "sp") %>%
                                  sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
```

## Leaflet   


### Paleta de colores 

Se crea una paleta de colores que se usar치 para mapear valores de una variable categ칩rica a colores en una visualizaci칩n de Leaflet.  

```{r}
paleta <- c("#13322B", #Muy alto
            "#086953", #Alto 
            "#4C9562", #Medio
            "#D1BB9E", #Bajo
            "#C3BA6D") # Muy bajo

            
## Paleta de colores                         
mypalette <- leaflet::colorFactor(palette = paleta, 
                                            domain = forcats::fct_relevel(DP2_2020$GM_2020, c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")), 
                                            na.color = "transparent")
```


### T칤tulo

Se define el estilo y el contenido de un t칤tulo para un mapa Leaflet utilizando `HTML` y `CSS` dentro de `R`.    

- `tags$style(HTML("..."))`: Esta funci칩n permite incluir estilos CSS en el documento.   
- `.leaflet-control.map-title`: Define una clase CSS que se aplicar치 al t칤tulo del mapa.  
- `tags$div(...)`: Crea un contenedor div en el cual se coloca el t칤tulo del mapa.  
- `tag.map.title`: Aplica los estilos definidos anteriormente a este contenedor div.  


```{r}
# Estructura del t칤tulo
tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px; 
    padding-right: 10px; 
    background: rgba(255,255,255,0.75);
    font-weight: bold;
    font-size: 28px;
  }
 ")) 

# Nota de p치gina
title <- tags$div(
  tag.map.title, HTML("Fuentes:Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci칩n y Vivienda 2020.")
)  
```

### L칤mites del mapa    

Se calcula el cuadro delimitador que contiene las coordenadas de los l칤mitesde un objeto espacial utilizando la funci칩n `st_bbox()` de la librer칤a `sf`.     

- `xmin`: La coordenada m칤nima en el eje x (longitud m칤nima).   
- `ymin`: La coordenada m칤nima en el eje y (latitud m칤nima).   
- `xmax`: La coordenada m치xima en el eje x (longitud m치xima).   
- `ymax`: La coordenada m치xima en el eje y (latitud m치xima).     

```{r}
bounding_box <- st_bbox(shape_estados_2020)
bounding_box
```
## Opciones de Leaflet {.tabset .tabset-fade .tabset-pills}    

### Opci칩n 1   

Se genera un mapa interactivo utilizando leaflet en R, a침adiendo diferentes capas de pol칤gonos para los a침os `2020`, `2015` y `2010`. Cada capa est치 coloreada seg칰n una paleta espec칤fica.      

- El mapa tiene un zoom fijo entre 5 y 5, sin controles de zoom.      
- A침ade capas de pol칤gonos para los estados en los a침os 2020, 2015 y 2010, coloreados seg칰n una variable espec칤fica (`GM_2020`, `GM_2015`, `GM_2010`) con una paleta definida (`mypalette`).    
- Establece l칤mites m치ximos del mapa basados en el cuadro delimitador de los datos.   
- Cada capa de pol칤gonos tiene caracter칤sticas visuales espec칤ficas como color de borde, opacidad y grosor de l칤nea.   

####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor. 


```{r}
map <- leaflet(options = leafletOptions(minZoom = 5, maxZoom = 5, zoomControl = FALSE)) %>% 
        addTiles() %>% 
         setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
          setMaxBounds(lng1 = bounding_box[1],
                       lat1 = bounding_box[2],
                       lng2 = bounding_box[3],
                       lat2 = bounding_box[4]) %>%
           addProviderTiles(providers$OpenStreetMap, 
                             options = providerTileOptions(minZoom = 5, maxZoom = 5)) 
```


####  Se a침aden las capas de pol칤gonos 

Se a침aden la capas de pol칤gonos al objeto de mapa `map`. Cada llamada a `addPolygons` a침ade una capa de pol칤gonos correspondiente a un a침o espec칤fico (`2020`, `2015`, `2010`).   

```{r}
map <- map %>%
        # capa "2020"
         addPolygons(data = shape_estados_2020,
                      fillColor = ~mypalette(GM_2020),
                       fillOpacity = 0.8,
                        stroke = TRUE, # Dibujar los bordes del pol칤gono
                         weight = 1,  # line thickness
                          dashArray = "1",
                           opacity = 1,
                            color = "#DBDBDB",  # line colour 
                             highlight = highlightOptions(weight = 2,
                                                          color = "red", # Color de selecci칩n
                                                          dashArray = "",
                                                          fillOpacity = 0.6,
                                                          bringToFront = TRUE),
                              group = "2020") %>%
        # capa "2015"
         addPolygons(data = shape_estados_2015,
                      fillColor =  ~mypalette(GM_2015),
                       fillOpacity = 0.8,
                        stroke = TRUE, # Dibujar los bordes del pol칤gono
                         weight = 1,  # line thickness
                          dashArray = "1",
                           opacity = 1,
                            color = "#DBDBDB",  # line colour 
                             highlight = highlightOptions(weight = 2,
                                                          color = "red", # Color de selecci칩n
                                                          dashArray = "",
                                                          fillOpacity = 0.6,
                                                          bringToFront = TRUE),
                              group = "2015") %>%
        # capa "2010"
         addPolygons(data = shape_estados_2010,
                      fillColor = ~mypalette(GM_2010),
                       fillOpacity = 0.8,
                        stroke = TRUE, # Dibujar los bordes del pol칤gono
                         weight = 1,  # line thickness
                          dashArray = "1",
                           opacity = 1,
                            color = "#DBDBDB",  # line colour 
                             highlight = highlightOptions(weight = 2,
                                                          color = "red", # Color de selecci칩n
                                                          dashArray = "",
                                                          fillOpacity = 0.6,
                                                          bringToFront = TRUE),
                              group = "2010")
```

#### Legend and features 

Se a침ade un control de t칤tulo en la esquina inferior derecha del mapa. Adem치s, se incluye una leyenda que muestra los colores y etiquetas correspondientes a los niveles de marginaci칩n, utilizando la paleta definida.     

- `addControl()`: A침ade un control de t칤tulo al mapa en la esquina inferior derecha. title es el objeto div que contiene el t칤tulo y los estilos definidos anteriormente.    
- `addLayersControl()`: A침ade un control de capas al mapa, permitiendo al usuario alternar entre las capas de los a침os `2020`, `2015` y `2010`.   
- `baseGroups = c("2020", "2015", "2010")`: Especifica los nombres de los grupos base que se mostrar치n en el control de capas.   

```{r}
map <- map %>%  
        addControl(title,
                   position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                     labels = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
                      values = ~forcats::fct_relevel(GM_2020, c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")),
                       title = stringr::str_wrap("Grado de marginaci칩n", 15),
                        opacity =  0.7) %>%
          addLayersControl(baseGroups = c("2020", "2015", "2010"),  # Nombres de los grupos
                            options = layersControlOptions(collapsed = FALSE))   
map
```

Se genera un Widget Interactivo con la funci칩n `saveWidget()`, 
  

**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).     

```{r, eval = FALSE}
saveWidget(map,  paste0(here::here(), "/index.html"), selfcontained = TRUE)

map <- map %>% 
        mapshot(url = paste0(here::here(), "/index.html")) 
```


### Opci칩n 2    

Se sigue la misma estructura que la **Opci칩n 1**, la 칰nica diferencia es que se encuentran reducidos todos los `addPolygons` dentro de un loop, en la que se define de manera previa se genera una funci칩n `addPolygonLayer`, que introduce todos los par치metros del addPolygons. De esta manera, hace que no se tengan que desplegar las capas de todos los a침os, y se realiza todo de manera simplificada.      

#### Se definen los a침os y los shapefiles    

- `years`: Un vector que contiene los a침os para los que tenemos datos de shapefiles.  
- Se asigna a la lista `shape_estados` los datos de shapefile correspondientes a cada a침o.      

```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")

shape_estados <- list(shape_estados_2020, shape_estados_2015, shape_estados_2010)
```


#### Se define una funci칩n para a침adir capas de pol칤gonos   

Se define una funci칩n llamada `addPolygonLayer`, la cual a침ade una capa de pol칤gonos a un mapa de Leaflet. Se tienen que especificar los argumentos:   

- `map`: El objeto de mapa de Leaflet al que se le a침adir치 la nueva capa de pol칤gonos.   
- `data`: Los datos que contienen la informaci칩n geogr치fica de los pol칤gonos.   
- `year`: A침o asociado con los datos de los pol칤gonos, usado para agrupar.    
- `paleta`: Paleta de colores que se usar치 para rellenar los pol칤gonos de acuerdo al grado de marginaci칩n.    

```{r}
# Define una funci칩n para a침adir capas de pol칤gonos
addPolygonLayer <- function(map, data, year, palette) {
                            map <- map %>%
                                    addPolygons(
                                                data = data,
                                                 fillColor = ~mypalette(get(paste0("GM_", year))),
                                                  fillOpacity = 0.8,
                                                   stroke = TRUE,
                                                    weight = 1.3,
                                                     dashArray = "1",
                                                      opacity = 1,
                                                       color = "#DBDBDB",  # line colour 
                                                        highlight = highlightOptions(weight = 2,
                                                                                     color = "red", # Color de selecci칩n
                                                                                     dashArray = "",
                                                                                     fillOpacity = 0.6,
                                                                                     bringToFront = TRUE),
                                                         group = year
                                                )
                             return(map)
}
```

####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor. 

```{r}
# Crear el mapa inicial
map <- leaflet(options = leafletOptions(minZoom = 5, maxZoom = 5, zoomControl = FALSE)) %>%
        addTiles() %>%
         setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
          setMaxBounds(lng1 = bounding_box[1],
                       lat1 = bounding_box[2],
                       lng2 = bounding_box[3],
                       lat2 = bounding_box[4]) %>%
           addProviderTiles(providers$OpenStreetMap, options = providerTileOptions(minZoom = 5, maxZoom = 5))
```


#### Funci칩n `addPolygonLayer()`   

Se a침aden las capas de pol칤gonos al mapa de Leaflet para cada combinaci칩n de a침o. Se recorren todas las combinaciones posibles de a침os (`years`), y se a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La lista shape_estados contiene los datos geogr치ficos organizados por a침o y grado, y la lista paleta proporciona la paleta de colores correspondiente para cada grado.    


```{r}
# A침adir capas de pol칤gonos para cada a침o
for (i in seq_along(years)) {
           map <- addPolygonLayer(map, shape_estados[[i]], years[i], mypalette)
}
```

#### Se a침ade la leyenda y control de capas    

Se a침aden los controles adicionales y una leyenda al mapa de Leaflet.   

- `addLayersControl()`: A침ade controles de capas al mapa.   
- `baseGroups = years`: Grupos de capas base entre los que el usuario puede cambiar.     
- `options = layersControlOptions(collapsed = FALSE)`: Opciones para los controles de capas, incluyendo que el control no est칠 colapsado por defecto.  

```{r}
map <- map %>%
        addControl(title, position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                     labels = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
                      values = ~forcats::fct_relevel(DP2_2020$GM_2020, c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")),
                  title = stringr::str_wrap("Grado de marginaci칩n", 15), opacity = 0.7) %>%
          addLayersControl(baseGroups = years, options = layersControlOptions(collapsed = FALSE))
 
# Mostrar el mapa
map
```

Se genera un Widget Interactivo con la funci칩n `saveWidget()`, 
  

**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).    
 
```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/img/map_2010_2020.html"), selfcontained = TRUE)
map <- map %>% 
        mapshot(url = paste0(here::here(), "/map_2010_2020.html"))
```

### Opci칩n 3   

Se sigue la misma estructura que la **Opci칩n 2**, se genera un lista de data frames geoespaciales correspondientes a diferentes a침os, y para cada data frame, a침ade varias columnas nuevas: una con IDs 칰nicos, otra con el a침o correspondiente, otra con una combinaci칩n de ID y a침o.   

**Vector y funci칩n**   
- `years`: Se define un vector con los a침os `2020`, `2015` y `2010`.     
- `generate_ids`: Es una funci칩n que genera una secuencia de n칰meros que los convierte en caracteres y les agrega ceros a la izquierda para que tengan al menos dos d칤gitos.       

Se generan algunas variables que van a ayudar a integrar los a침os y los grados de marginaci칩n dentro del leaflet de manera din치mica.      

- `ID`: Se genera IDs 칰nicos para cada entidad, utilizando la funci칩n `generate_ids`. Por ejemplo, para el primer a침o (2020), generar치 IDs del 1 al 32; para el segundo a침o (2015), del 33 al 64; y para el tercer a침o (2010), del 65 al 96.      
- `ANIO`: Agrega una columna con el a침o correspondiente (`2020`, `2015` o `2010`).     
- `id_year`: Crea una columna que combina el ID generado con el a침o correspondiente, por ejemplo, 0102020, 0202020, etc.    


```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")
shape_estados <- list(shape_estados_2020, shape_estados_2015, shape_estados_2010)

# Funci칩n para generar el ID de 1 a 96
generate_ids <- function(start, end) {
  str_pad(as.character(seq(start, end)), 2, "left", pad = "0")
}

# Aplicar la transformaci칩n a cada lista de shape_estados
for (i in seq_along(years)) {
  shape_estados[[i]] <- shape_estados[[i]] %>%
    mutate(ID = generate_ids(((i - 1) * 32 + 1), i * 32),
           ANIO = years[i],
           id_year = paste0(generate_ids(((i - 1) * 32 + 1), i * 32), years[i]))
}
```

#### Se define una funci칩n para a침adir capas de pol칤gonos   

Se define una funci칩n llamada `addPolygonLayer`, la cual a침ade una capa de pol칤gonos a un mapa de Leaflet. Se tienen que especificar los argumentos:   

- `map`: El objeto de mapa de Leaflet al que se le a침adir치 la nueva capa de pol칤gonos.   
- `data`: Los datos que contienen la informaci칩n geogr치fica de los pol칤gonos.   
- `year`: A침o asociado con los datos de los pol칤gonos, usado para agrupar.    
- `paleta`: Paleta de colores que se usar치 para rellenar los pol칤gonos de acuerdo al grado de marginaci칩n.   
- `grado`: Representa el grupo al que pertenecen estos pol칤gonos.    
- `id`: Es el identificador 칰nico para esta capa de pol칤gonos en el mapa. Puede ser 칰til para identificar y manipular espec칤ficamente esta capa en operaciones posteriores.    

```{r}
# Define una funci칩n para a침adir capas de pol칤gonos
addPolygonLayer <- function(map, data, year, grado, paleta, id) {
                            map <- map %>%
                                    addPolygons(
                                                data = data,
                                                 fillColor = paleta,
                                                  fillOpacity = 0.8,
                                                   stroke = TRUE,
                                                    weight = 1,
                                                     dashArray = "1",
                                                      opacity = 1.3,
                                                       color = "#DBDBDB",  # line colour 
                                                        highlight = highlightOptions(weight = 2,
                                                                                     color = "red", # Color de selecci칩n
                                                                                     dashArray = "",
                                                                                     fillOpacity = 0.6,
                                                                                     bringToFront = TRUE),
                                                         group = grado,
                                                          layerId = id
                                                )
                             return(map)
}
```

####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor. 


```{r}
# Crear el mapa inicial
map <- leaflet(options = leafletOptions(minZoom = 5, maxZoom = 5, zoomControl = FALSE)) %>%
        addTiles() %>%
         setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
          setMaxBounds(lng1 = bounding_box[1],
                       lat1 = bounding_box[2],
                       lng2 = bounding_box[3],
                       lat2 = bounding_box[4]) %>%
           addProviderTiles(providers$OpenStreetMap, options = providerTileOptions(minZoom = 5, maxZoom = 5))

```



#### Funci칩n `addPolygonLayer()`   

Se construye din치micamente un mapa interactivo que muestra diferentes capas de pol칤gonos para los a침os `2020`, `2015` y `2010`, utilizando funciones y enfoques que permiten manejar de manera flexible los datos geoespaciales. Cada iteraci칩n del bucle a침ade una nueva capa de pol칤gonos al mapa `map`, lo que permite visualizar los datos geoespaciales para cada a침o de manera superpuesta en el mismo mapa interactivo. Se recorren todas las combinaciones posibles de a침os (`years`), y se a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La funci칩n contiene, los shape_estados que son los datos geogr치ficos organizados por a침o y grado, la paleta de colores correspondiente para cada grado y el ID unico de cada observaci칩n correspondiente a cada a침o.  

```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

# A침adir capas de pol칤gonos para cada a침o
for (i in seq_along(years)) {
           map <- addPolygonLayer(map, 
                                  data = shape_estados[[i]], 
                                  year = ~ANIO, 
                                  grado = ~get(paste0("GM_", years[i])), 
                                  paleta = ~mypalette(get(paste0("GM_", years[i]))), 
                                  id = ~id_year
                                  )
}
```

#### Se a침ade la leyenda y control de capas    

Se a침aden los controles adicionales y una leyenda al mapa de Leaflet. Permitiendo al usuario explorar diferentes capas de datos y visualizar informaci칩n geoespacial de manera organizada y comprensible.     

- `addLayersControl()`: Agrega un control de capas al mapa para permitir al usuario seleccionar qu칠 capas base u overlay (superpuestas) desea visualizar.   
- `overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")`: Define los grupos de capas superpuestas que se mostrar치n en el control de capas. En este caso, parecen ser categor칤as de grado de marginaci칩n.   
- `baseGroups = c("2020", "2015", "2010")`: Define los grupos de capas base que se mostrar치n en el control de capas. Estos podr칤an ser los a침os para los cuales se est치n visualizando datos.    
- `options = layersControlOptions(collapsed = FALSE)`:  Especifica las opciones del control de capas. collapsed = FALSE significa que el control de capas estar치 expandido por defecto, mostrando todas las opciones disponibles sin necesidad de expandirlo manualmente.     

```{r}
map <- map %>%
        addControl(title, position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                    labels = grados,
                    title = stringr::str_wrap("Grado de marginaci칩n", 15), 
                    opacity = 0.7) %>%
          addLayersControl(
           overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
            baseGroups = c("2020", "2015", "2010"), 
             options = layersControlOptions(collapsed = FALSE))
```

#### Se configura el control de capas     

El bloque de este c칩digo JavaScript se utiliza junto con el paquete `htmlwidgets`  para controlar la visibilidad y la interactividad de las capas en un mapa Leaflet. Este c칩digo JavaScript personalizado mejora la funcionalidad de un mapa Leaflet al permitir que el usuario controle din치micamente qu칠 capas base y superpuestas est치n visibles en el mapa. Al cambiar la capa base o a침adir capas superpuestas, las capas que no corresponden se ocultan autom치ticamente, manteniendo as칤 una visualizaci칩n clara y organizada de los datos geoespaciales.     

Los eventos `baselayerchange`, `overlayadd`, `overlayremove`: A침aden eventos para actualizar las capas visibles cuando el usuario cambia la capa base o a침ade/remueve capas superpuestas.   

- `baselayerchange`: Este evento se activa cuando el usuario cambia la capa base del mapa.
- `overlayadd`: Este evento se activa cuando se a침ade una capa superpuesta al mapa.

```{r}
map <- map %>%
        htmlwidgets::onRender("
          function(el, x) {
            var myMap = this;
            var baseLayer = '2020';
            myMap.eachLayer(function(layer) {
              var id = layer.options.layerId;
              if (id) {
                if (!id.endsWith(baseLayer)) {
                  layer.getElement().style.display = 'none';
                }
              }
            });
      
            myMap.on('baselayerchange', function(e) {
              baseLayer = e.name;
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                    layer.closePopup();
                  } 
                  else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
      
            myMap.on('overlayadd', function(e) {
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                  } else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
          }")
```


Se genera un Widget Interactivo con la funci칩n `saveWidget()`, 
  

**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).    
 
```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/img/map_2010_2020.html"), selfcontained = TRUE)
map <- map %>% 
        mapshot(url = paste0(here::here(), "/map_2010_2020.html"))
```


# Librer칤as

**Librer칤as que se usaron en el trabajo**

```{r, echo = FALSE, eval = TRUE}
sesion_info <- devtools::session_info()
knitr::kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
 kableExtra::kable_classic(full_width = TRUE, html_font = 'Montserrat Medium', font_size = 10) 
```


<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Licence" style="border-width:0"/></a><br />This work by [**Diana Villasana Ocampo**]{xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"} is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.  
