---
title: "Leaflet por grados de marginaci칩n, 2010 - 2020"
subtitle: "Utilizando capas `rmapsahper`"
author: "Diana Villasana Ocampo"
output:
   html_document:
      highlight: tango
      theme: flatly
      toc: yes
      toc_depth: 4
      toc_float:
        collapsed: yes
knit: (function(input, ...) {
    rmarkdown::render(
      input,
      output_dir = "../../docs"
    )
  })
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 14px
}
h1.title {
  font-size: 40px;
  color: #1C3BA4;
}
h1 {
  color: #B6854D;
}
h2 {
  color: #172984;
}
h3 {
  color: #172984;
}
h5 {
  color: #B6854D;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE, 
                         eval = FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
options(digits = 2)
``` 


```{r, echo = FALSE, results=FALSE, eval = TRUE}
require(dplyr)
require(forcats)
require(sp)
require(stringr)
require(spdplyr)
require(htmltools)
require(leaflet)
require(htmlwidgets)
require(ggmap)
require(ggplot2)
require(ggridges)
require(grDevices)
require(ggpubr)
require(forcats)
require(rgdal)
require(tibble)
require(sf)
require(stringr)
require(RColorBrewer)
require(leafgl)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
require(rmapshaper)
require(geojsonio)
```

# Sistema de Informaci칩n Geogr치fica

El Instituto Nacional de Estad칤stica, Geograf칤a e Inform치tica (INEGI) tiene puestos a disposici칩n del p칰blico los shapefiles con los distintos niveles de informaci칩n geogr치fica. Estos archivos digitales se encuentran disponibles en el [`Marco Geoestad칤stico Nacional (MGN)`](https://www.inegi.org.mx/temas/mg/#Descargas), el cual es un sistema 칰nico y se presenta la divisi칩n del territorio nacional en diferentes niveles de desagregaci칩n para referir geogr치ficamente la informaci칩n estad칤stica de los censos y encuestas. Se integra al Sistema Nacional de Informaci칩n Estad칤stica y Geogr치fica (SNIEG).


## 칈ndice de marginaci칩n 2010 - 2020

Se cargan las bases de datos del 칤ndice de marginaci칩n a nivel estatal para los a침os `2010`, `2015` y `2020`. Las cuales se encuentran en formato `.RData`.   

**Bases de datos**   
- Nivel estatal    
- Nivel municipal   
- Nivel localidad   
- Nivel AGEB  
- Nivel Colonia    

**Base de datos** de los tres a침os se encuentran disponibles en la p치gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de M칠xico** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicaci칩n** [칈ndice De Marginaci칩n Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)     


```{r}
tablas <- c("2010", "2015", "2020")
for(i in tablas){
load(file = paste0(here::here(), "/Output/IME_", i, ".RData"))
}
```


## Shapefiles

A continuaci칩n, se leen y se transforman los shapefiles de las divisiones geogr치ficas de los estados de M칠xico correspondientes a los a침os `2020`, `2015` y `2010`.   

Utilizando la paqueter칤a `rgdal`, se definen los siguientes par치metros:      
 
- `readOGR`: Esta funci칩n se usa para leer shapefiles.   
- `dsn`: Especifica la ruta al directorio que contiene el shapefile.  
- `layer`: Especifica el nombre de la capa dentro del shapefile.  
- `encoding`: Especifica la codificaci칩n de los caracteres, en este caso, UTF-8.  
- `use_iconv`: Se usa para convertir la codificaci칩n si es necesario.  

Una vez cargados los sahpefiles, se transforman los sistemas de coordenadas:     

- `spTransform`: Esta funci칩n se usa para transformar las coordenadas del shapefile a un nuevo sistema de referencia.    
- `CRSobj`: Especifica el sistema de referencia de coordenadas de destino. En este caso, se usa el sistema de coordenadas geogr치ficas (latitud y longitud) basado en el elipsoide y `datum WGS84`.    


Estos pasos son cruciales para asegurar que los datos geoespaciales sean consistentes y compatibles para su uso en an치lisis geogr치ficos y visualizaci칩n, por ejemplo, en aplicaciones de Leaflet o cualquier otro software de mapeo.   

**Shapefile estados 2020**

```{r, eval = FALSE}
shape_estados_2020 <- readOGR(dsn = "D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos",
                               layer = "00ent",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2020 <- spTransform(shape_estados_2020, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2015**

```{r, eval = FALSE}
shape_estados_2015 <- readOGR(dsn ="D:/MGN/MGN Junio 2016/conjunto_de_datos", 
                               layer = "areas_geoestadisticas_estatales",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)

shape_estados_2015 <- spTransform(shape_estados_2015, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```

**Shapefile estados 2010**

```{r, eval = FALSE}
shape_estados_2010 <- readOGR(dsn ="D:/MGN/MGN 2010 Version 4.3 (Jul-Dic 2009)/32_Entidades_Federativas", 
                               layer = "ESTADOS",
                                encoding = "UTF-8",
                                 use_iconv = TRUE)
shape_estados_2010 <- spTransform(shape_estados_2010, CRSobj = CRS('+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs'))
```



### ShapefilesDataFrame

Se cambian de `IDs` de los Features del Shapefile; de esta manera si se hace alguna manipulaci칩n al shapefile directamente los pol칤gonos tendr치n el ID de la clave de la entidad y conservar치n el orden. Adem치s de que es 칰til cuando se necesita asegurar que los IDs de las entidades geogr치ficas sean consistentes en longitud y formato para su posterior an치lisis o visualizaci칩n.     

- `sp::spChFIDs` cambia los IDs de las features del objeto Spatial.
- `str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0")`: Utiliza la funci칩n `str_pad()` para rellenar con ceros a la izquierda (si es necesario) para asegurarse de que cada ID tenga al menos 2 d칤gitos.     


```{r, eval = FALSE}
shape_estados_2020 <- shape_estados_2020 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2020@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2015 <- shape_estados_2015 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2015@data$CVE_ENT, 2, "left", pad = "0"))

shape_estados_2010 <- shape_estados_2010 %>%
                       select(CVE_ENT) %>%
                         sp::spChFIDs(., str_pad(shape_estados_2010@data$CVE_ENT, 2, "left", pad = "0"))
```



**Se insertan los datos del 칤ndice de marginaci칩n y se seccionan por grado de marginaci칩n**  

Este c칩digo realiza las siguientes acciones:

- Selecciona las columnas `CVE_ENT` y `GM_` del dataframe `DP2_`.   
- `stringr::str_trim(.$GM_, "both")`: Elimina los espacios en blanco al principio y al final de los valores en `GM_`.   
- `fct_relevel(..., c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))`: Reordena los niveles del factor `GM_` en el orden especificado.   
- `spdplyr:::left_join.Spatial()`,  Realiza un merge entre shape_estados_ y el dataframe modificado, usando `CVE_ENT` como clave.   

El resultado es un nuevo objeto Spatial (capa_estados_2020) que combina la geometr칤a de shape_estados_2020 con la informaci칩n adicional de `DP2_`, incluyendo la columna `GM_` con niveles reordenados.    



```{r, eval = FALSE}
capa_estados_2020 <- shape_estados_2020 %>%
                      spdplyr:::left_join.Spatial(., DP2_2020 %>% 
                                                      select(CVE_ENT, GM_2020) %>%  
                                                       mutate(GM_2020 = fct_relevel(stringr::str_trim(.$GM_2020, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2015 <- shape_estados_2015 %>%
                      spdplyr:::left_join.Spatial(., DP2_2015 %>% 
                                                      select(CVE_ENT, GM_2015) %>%  
                                                       mutate(GM_2015 = fct_relevel(stringr::str_trim(.$GM_2015, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 

capa_estados_2010 <- shape_estados_2010 %>%
                      spdplyr:::left_join.Spatial(., DP2_2010 %>% 
                                                      select(CVE_ENT, GM_2010) %>%  
                                                       mutate(GM_2010 = fct_relevel(stringr::str_trim(.$GM_2010, "both"), c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"))),
                                                        by = c("CVE_ENT")) 
```

### Capas de estados separados por el grado de marginaci칩n   
 
Se crean listas de capas de pol칤gonos filtrados por los grados de marginaci칩n para los a침os `2020`, `2015` y `2010`.   
- Las listas (`layers_estados_2020`, `layers_estados_2015`, `layers_estados_2010`), cada una con cinco elementos. Cada elemento es una capa de pol칤gonos filtrada por un grado de marginaci칩n espec칤fico.

```{r, eval = FALSE}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

layers_estados_2020 <- list()
layers_estados_2015 <- list()
layers_estados_2010 <- list()
for(i in 1:5){
  layers_estados_2020[[i]] <- capa_estados_2020  %>%
                               filter(GM_2020 == grados[i])
  layers_estados_2015[[i]] <- capa_estados_2015  %>%
                               filter(GM_2015 == grados[i])
  layers_estados_2010[[i]] <- capa_estados_2010  %>%
                               filter(GM_2010 == grados[i])
}
```


### `geojson_json()` (Por grados de marginaci칩n)    

Se convierten las capas de pol칤gonos filtrados en objetos `GeoJSON`. Este proceso es 칰til para guardar las capas en un formato que puede ser f치cilmente utilizado para visualizaci칩n en la web o en aplicaciones de mapas interactivos.     

- `geojsonio::geojson_json`: Esta funci칩n convierte un objeto espacial a formato `GeoJSON`.  
- `geometry = "polygon"`: Especifica que las geometr칤as deben ser de tipo pol칤gono. Esto es adecuado para las entidades geogr치ficas de los estados que generalmente se representan como pol칤gonos.   
- `geojsonio::geojson_write`: Esta funci칩n escribe un objeto GeoJSON a un archivo.   


Esto es 칰til para guardar y compartir datos espaciales en un formato ampliamente compatible, como GeoJSON, que puede ser f치cilmente utilizado en aplicaciones web, sistemas de informaci칩n geogr치fica (SIG), y otros contextos de an치lisis y visualizaci칩n de datos geoespaciales.    


```{r, eval = FALSE}
capa_estados_2020_json <- list()
capa_estados_2015_json <- list()
capa_estados_2010_json <- list()
for(i in 1:5){
  capa_estados_2020_json[[i]] <- geojsonio::geojson_json(layers_estados_2020[[i]], geometry = "polygon")
  capa_estados_2015_json[[i]] <- geojsonio::geojson_json(layers_estados_2015[[i]], geometry = "polygon")
  capa_estados_2010_json[[i]] <- geojsonio::geojson_json(layers_estados_2010[[i]], geometry = "polygon")
}
```

### Capas simplificadas (Por grados de marginaci칩n)   

La funci칩n `ms_simplify` del paquete `rmapshaper` sirve para simplificar las geometr칤as de los pol칤gonos en tres conjuntos de datos:   `capa_estados_2020_json`, `capa_estados_2015_json` y `capa_estados_2010_json`. La simplificaci칩n se hace con el objetivo de reducir la cantidad de puntos que definen las geometr칤as, manteniendo una representaci칩n aproximada de las mismas y mejorando el rendimiento del mapa, ya que las geometr칤as simplificadas requieren menos recursos computacionales y tiempo para ser dibujadas.     

La funci칩n `ms_simplify()`, es muy 칰til para simplificar geometr칤as, pero encontrar un equilibrio entre la simplificaci칩n y la preservaci칩n de la forma original de los pol칤gonos puede requerir ajustes cuidadosos de los par치metros. Aqu칤 tienes algunas recomendaciones y opciones de par치metros que puedes ajustar:     

- `keep`: controla la proporci칩n de puntos originales que se mantienen. Un valor m치s alto mantendr치 m치s detalles y un valor m치s bajo reducir치 m치s puntos.     
- keep_shapes: asegura que la forma general del pol칤gono se conserve mejor durante la simplificaci칩n.  Ejemplo: `keep_shapes = TRUE`. 
 - `weighting`: controla c칩mo se ponderan los puntos en la simplificaci칩n. Un valor positivo har치 que los puntos con mayor densidad sean menos simplificados. Ejemplo, `weighting = 1`.     
- `snap = TRUE`: puede usarse para evitar que los puntos de los pol칤gonos se desv칤en demasiado lejos de su posici칩n original.   

```{r, eval = FALSE}
capa_estados_2020_mapshaper <- list()
capa_estados_2015_mapshaper <- list()
capa_estados_2010_mapshaper <- list()
for(i in 1:5){
  capa_estados_2020_mapshaper[[i]] <- rmapshaper::ms_simplify(capa_estados_2020_json[[i]], keep = 0.5, weighting = 0.9, keep_shapes = TRUE, snap = TRUE)
  capa_estados_2015_mapshaper[[i]] <- rmapshaper::ms_simplify(capa_estados_2015_json[[i]], keep = 0.5, weighting = 0.9, keep_shapes = TRUE, snap = TRUE)
  capa_estados_2010_mapshaper[[i]] <- rmapshaper::ms_simplify(capa_estados_2010_json[[i]], keep = 0.5, weighting = 0.9, keep_shapes = TRUE, snap = TRUE)
}
```

丘뒲잺 **Comparativo de tama침os**

```{r, eval = FALSE}
object.size(capa_estados_2010_json)/ 2^20
object.size(capa_estados_2010_mapshaper)/ 2^20
```


### `geojson_write()`

La funci칩n` geojson_write` del paquete `geojsonio` para escribir archivos `GeoJSON` a partir de los datos en las listas.  Este c칩digo permitir치 generar m칰ltiples archivos GeoJSON, uno para cada combinaci칩n de a침o (`2020`, `2015`, `2010`) y  dentro cada grado de marginaci칩n.   

```{r, eval = FALSE}
for(i in 1:5){
 geojsonio::geojson_write(capa_estados_2020_json[[i]], file = paste0(here::here(), "/Output/estados_2020_", i, "_json.geojson")) 
 geojsonio::geojson_write(capa_estados_2015_json[[i]], file = paste0(here::here(), "/Output/estados_2015_", i, "_json.geojson")) 
 geojsonio::geojson_write(capa_estados_2010_json[[i]], file = paste0(here::here(), "/Output/estados_2010_", i, "_json.geojson")) 
}
```


## GeoJson (Estados)  

游녢 Se vuelve a leer un archivo `GeoJSON ` y realizan algunas operaciones adicionales en el objeto espacial resultante:   

- `geojsonio::geojson_read()`: Esta funci칩n lee un archivo GeoJSON y lo convierte en un objeto espacial.   
- `what = "sp"`: Especifica que el resultado debe ser un objeto Spatial (de la clase `sp`) y no un formato lineal `.json`.  
- `sp::spChFIDs`: Esta funci칩n cambia los IDs de las features (FIDs) del objeto Spatial.    

```{r}
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

shape_estados_2020 <- list()
shape_estados_2015 <- list()
shape_estados_2010 <- list()
for (i in 1:5){
  shape_estados_2020[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2020_", i, "_json.geojson"), what = "sp") %>%
                                    sp::spChFIDs(.,  str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
  shape_estados_2015[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2015_", i, "_json.geojson"), what = "sp") %>%
                                    sp::spChFIDs(.,  str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
  shape_estados_2010[[paste0(grados[i])]] <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2010_", i, "_json.geojson"), what = "sp") %>% 
                                    sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
}

shape_estados <- geojsonio::geojson_read(paste0(here::here(), "/Output/estados_2020_json.geojson"), what = "sp") %>%
                                          sp::spChFIDs(., str_pad(.@data$CVE_ENT, 2, "left", pad = "0"))
```

## Leaflet 

### Paleta de colores  

Se crea una paleta de colores que se usar치 para mapear valores de una variable categ칩rica a colores en una visualizaci칩n de Leaflet.  

```{r}
paleta <- c("#13322B", #Muy alto
            "#086953", #Alto 
            "#4C9562", #Medio
            "#D1BB9E", #Bajo
            "#C3BA6D") # Muy bajo

            
## Paleta de colores                         
mypalette <- leaflet::colorFactor(palette = paleta, 
                                            domain = forcats::fct_relevel(DP2_2020$GM_2020, c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")), 
                                            na.color = "transparent")
```


### T칤tulo 

Se define el estilo y el contenido de un t칤tulo para un mapa Leaflet utilizando `HTML` y `CSS` dentro de `R`.    

- `tags$style(HTML("..."))`: Esta funci칩n permite incluir estilos CSS en el documento.   
- `.leaflet-control.map-title`: Define una clase CSS que se aplicar치 al t칤tulo del mapa.  
- `tags$div(...)`: Crea un contenedor div en el cual se coloca el t칤tulo del mapa.  
- `tag.map.title`: Aplica los estilos definidos anteriormente a este contenedor div.  

```{r}
# Estructura del t칤tulo
tag.map.title <- tags$style(HTML("
  .leaflet-control.map-title { 
    transform: translate(-50%,20%);
    position: fixed !important;
    left: 50%;
    text-align: center;
    padding-left: 10px; 
    padding-right: 10px; 
    background: rgba(255,255,255,0.75);
    font-weight: bold;
    font-size: 28px;
  }
 ")) 

# Nota de p치gina
title <- tags$div(
  tag.map.title, HTML("Fuentes:Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci칩n y Vivienda 2020.")
)  
```

### L칤mites del mapa    

Se calcula el cuadro delimitador que contiene las coordenadas de los l칤mitesde un objeto espacial utilizando la funci칩n `st_bbox()` de la librer칤a `sf`.     

- `xmin`: La coordenada m칤nima en el eje x (longitud m칤nima).   
- `ymin`: La coordenada m칤nima en el eje y (latitud m칤nima).   
- `xmax`: La coordenada m치xima en el eje x (longitud m치xima).   
- `ymax`: La coordenada m치xima en el eje y (latitud m치xima).     

```{r}
bounding_box <- st_bbox(shape_estados)
bounding_box
```
### Leaflet estructura   

#### Se definen los a침os y los grados de marginaci칩n    

- `years`: Un vector que contiene los a침os para los que tenemos datos de shapefiles.  
- `grados`: Un vector que contiene los niveles de marginaci칩n.  

Se asigna a la lista `shape_estados` con una estrcutura de listas de data frames geoespaciales correspondientes a diferentes a침os y grados de marginaci칩n. Para cada data frame de los `SpatiaPolygonsDataFrame`, se le a침aden varias columnas nuevas: una con IDs 칰nicos, otra con el a침o correspondiente, otra con una combinaci칩n de ID y a침o.     

**Vector y funci칩n**   
- `years`: Se define un vector con los a침os `2020`, `2015` y `2010`.     
- `generate_ids`: Es una funci칩n que genera una secuencia de n칰meros que los convierte en caracteres y les agrega ceros a la izquierda para que tengan al menos dos d칤gitos.      - `map2(shape_estados, years, ...)`: La funci칩n en conjunto transforma los shapefiles de cada a침o y grado, generando IDs 칰nicos y a침adiendo columnas adicionales que ayudan a identificar cada observaci칩n con un ID y un a침o espec칤ficos.     

Se generan algunas variables que van a ayudar a integrar los a침os y los grados de marginaci칩n dentro del leaflet de manera din치mica.      

- `ID`: Se genera IDs 칰nicos para cada entidad, utilizando la funci칩n `generate_ids`. Por ejemplo, para el primer a침o (2020), generar치 IDs del 1 al 32; para el segundo a침o (2015), del 33 al 64; y para el tercer a침o (2010), del 65 al 96. Tomando en cuenta que cada a침o, se encuentra estructurado por un grupo de listas que corresponden a los diferentes grados de marginaci칩n.          
- `ANIO`: Agrega una columna con el a침o correspondiente (`2020`, `2015` o `2010`).     
- `id_year`: Crea una columna que combina el ID generado con el a침o correspondiente, por ejemplo, 0102020, 0202020, etc.   


```{r}
# Define los grados y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

shape_estados <- NULL
shape_estados <- list(shape_estados_2020, shape_estados_2015, shape_estados_2010)

# Funci칩n para generar el ID del 1 a 96
generate_ids <- function(start, end) {
                  str_pad(as.character(seq(start, end)), 2, "left", pad = "0")
}

# Aplicar la transformaci칩n a cada lista de shape_estados
start_id <- 1
shape_estados <- map2(shape_estados, years, function(shape_files, year) {
                            shape_files <- map2(shape_files, grados, function(shape_file, grado) {
                                                 if (is.data.frame(shape_file@data)) {
                                                      end_id <- start_id + nrow(shape_file) - 1
                                                      shape_file <- shape_file %>%
                                                                     mutate(ID = generate_ids(start_id, end_id),
                                                                            ANIO = year,
                                                                            id_year = paste0(generate_ids(start_id, end_id), year))
                                                      start_id <<- end_id + 1
                                                     }
                                                 shape_file
                                                  }
                                                )
                            shape_files
  }
)
```


#### Se define una funci칩n para a침adir capas de pol칤gonos   

Se define una funci칩n llamada `addPolygonLayer`, la cual a침ade una capa de pol칤gonos a un mapa de Leaflet. Se tienen que especificar los argumentos:   

- `map`: El objeto de mapa de Leaflet al que se le a침adir치 la nueva capa de pol칤gonos.   
- `data`: Los datos que contienen la informaci칩n geogr치fica de los pol칤gonos.   
- `year`: A침o asociado con los datos de los pol칤gonos, usado para agrupar.    
- `paleta`: Paleta de colores que se usar치 para rellenar los pol칤gonos de acuerdo al grado de marginaci칩n.   
- `grado`: Representa el grupo al que pertenecen estos pol칤gonos.    
- `id`: Es el identificador 칰nico para esta capa de pol칤gonos en el mapa. Puede ser 칰til para identificar y manipular espec칤ficamente esta capa en operaciones posteriores. 

```{r}
# Define una funci칩n para a침adir capas de pol칤gonos
addPolygonLayer <- function(map, data, year, grado, paleta, id) {
                            map <- map %>%
                                    addPolygons(data = data,
                                                 fillColor = paleta,
                                                  fillOpacity = 0.8,
                                                   stroke = TRUE,
                                                    weight = 1,
                                                     dashArray = "1",
                                                      opacity = 1.3,
                                                       color = "#DBDBDB",  # line colour 
                                                        highlight = highlightOptions(weight = 2,
                                                                                     color = "red", # Color de selecci칩n
                                                                                     dashArray = "",
                                                                                     fillOpacity = 0.6,
                                                                                     bringToFront = TRUE),
                                                         group = grado,
                                                          layerId = id
                                                )
                             return(map)
}
```

####  Se crea el mapa inicial   

Se crea un mapa centrado en unas coordenadas espec칤ficas (`lat = 23.6260333` y `lng = -102.5375005`), con un nivel de zoom fijo, y establece los l칤mites m치ximos para evitar que el usuario se desplace fuera de una regi칩n definida. El mapa utiliza capa de OpenStreetMap tanto en la capa base como en una capa adicional de tiles del mismo proveedor. 

```{r}
# Crear el mapa inicial
map <- leaflet(options = leafletOptions(minZoom = 5, maxZoom = 5, zoomControl = FALSE)) %>%
        addTiles() %>%
         setView(lat = 23.6260333, lng = -102.5375005, zoom = 5) %>%
          setMaxBounds(lng1 = bounding_box[1],
                       lat1 = bounding_box[2],
                       lng2 = bounding_box[3],
                       lat2 = bounding_box[4]) %>%
           addProviderTiles(providers$OpenStreetMap, options = providerTileOptions(minZoom = 5, maxZoom = 5))
```


#### Funci칩n `addPolygonLayer()`   

Se a침aden las capas de pol칤gonos al mapa de Leaflet para cada combinaci칩n de a침o y grado. Se recorren todas las combinaciones posibles de a침os (`years`) y grados (`grados`), y para cada combinaci칩n, a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La lista shape_estados contiene los datos geogr치ficos organizados por a침o y grado, y la lista paleta proporciona la paleta de colores correspondiente para cada grado.    


#### Funci칩n `addPolygonLayer()`   

Se construye din치micamente un mapa interactivo que muestra diferentes capas de pol칤gonos para los a침os `2020`, `2015` y `2010`, utilizando funciones y enfoques que permiten manejar de manera flexible los datos geoespaciales. Cada iteraci칩n del bucle a침ade una nueva capa de pol칤gonos al mapa `map`, lo que permite visualizar los datos geoespaciales para cada a침o de manera superpuesta en el mismo mapa interactivo. Se recorren todas las combinaciones posibles de a침os (`years`), y se a침ade una capa de pol칤gonos al mapa utilizando la funci칩n `addPolygonLayer`. La funci칩n contiene, los shape_estados que son los datos geogr치ficos organizados por a침o y grado, la paleta de colores correspondiente para cada grado y el ID unico de cada observaci칩n correspondiente a cada a침o.  

```{r}
# Define los datos y a침os
years <- c("2020", "2015", "2010")
grados <- c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")

# A침adir capas de pol칤gonos para cada a침o
for (i in seq_along(years)) {
  for(j in seq_along(grados)){
           map <- addPolygonLayer(map, 
                                  data = shape_estados[[i]][[j]], 
                                  year = ~ANIO, 
                                  grado = ~get(paste0("GM_", years[i])), 
                                  paleta = ~mypalette(get(paste0("GM_", years[i]))), 
                                  id = ~id_year
                                  )
  }
}
```


#### Se a침ade la leyenda y control de capas    

Se a침aden los controles adicionales y una leyenda al mapa de Leaflet. Permitiendo al usuario explorar diferentes capas de datos y visualizar informaci칩n geoespacial de manera organizada y comprensible.     

- `addLayersControl()`: Agrega un control de capas al mapa para permitir al usuario seleccionar qu칠 capas base u overlay (superpuestas) desea visualizar.   
- `overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")`: Define los grupos de capas superpuestas que se mostrar치n en el control de capas. En este caso, parecen ser categor칤as de grado de marginaci칩n.   
- `baseGroups = c("2020", "2015", "2010")`: Define los grupos de capas base que se mostrar치n en el control de capas. Estos podr칤an ser los a침os para los cuales se est치n visualizando datos.    
- `options = layersControlOptions(collapsed = FALSE)`:  Especifica las opciones del control de capas. collapsed = FALSE significa que el control de capas estar치 expandido por defecto, mostrando todas las opciones disponibles sin necesidad de expandirlo manualmente.         

```{r}
map <- map %>%
        addControl(title, position = "bottomright") %>%
         addLegend("bottomright", 
                    colors = paleta, 
                    labels = grados,
                    title = stringr::str_wrap("Grado de marginaci칩n", 15), 
                    opacity = 0.7) %>%
          addLayersControl(
           overlayGroups = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo"),
            baseGroups = c("2020", "2015", "2010"), 
             options = layersControlOptions(collapsed = FALSE))
```

#### Se configura el control de capas     

El bloque de este c칩digo JavaScript se utiliza junto con el paquete `htmlwidgets`  para controlar la visibilidad y la interactividad de las capas en un mapa Leaflet. Este c칩digo JavaScript personalizado mejora la funcionalidad de un mapa Leaflet al permitir que el usuario controle din치micamente qu칠 capas base y superpuestas est치n visibles en el mapa. Al cambiar la capa base o a침adir capas superpuestas, las capas que no corresponden se ocultan autom치ticamente, manteniendo as칤 una visualizaci칩n clara y organizada de los datos geoespaciales.     

Los eventos `baselayerchange`, `overlayadd`, `overlayremove`: A침aden eventos para actualizar las capas visibles cuando el usuario cambia la capa base o a침ade/remueve capas superpuestas.   

- `baselayerchange`: Este evento se activa cuando el usuario cambia la capa base del mapa.
- `overlayadd`: Este evento se activa cuando se a침ade una capa superpuesta al mapa.

```{r}
map <- map %>%
        htmlwidgets::onRender("
          function(el, x) {
            var myMap = this;
            var baseLayer = '2020';
            myMap.eachLayer(function(layer) {
              var id = layer.options.layerId;
              if (id) {
                if (!id.endsWith(baseLayer)) {
                  layer.getElement().style.display = 'none';
                }
              }
            });
      
            myMap.on('baselayerchange', function(e) {
              baseLayer = e.name;
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                    layer.closePopup();
                  } 
                  else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
      
            myMap.on('overlayadd', function(e) {
              myMap.eachLayer(function(layer) {
                var id = layer.options.layerId;
                if (id) {
                  if (!id.endsWith(baseLayer)) {
                    layer.getElement().style.display = 'none';
                  } else {
                    layer.getElement().style.display = 'block';
                  }
                }
              });
            });
          }")
map
```


Se genera un Widget Interactivo con la funci칩n `saveWidget()`, 
  

**Consideraciones**   

- `saveWidget`: Guarda el mapa interactivo como un archivo HTML, ideal para ser compartido y visualizado en navegadores web.    
- `selfcontained = TRUE`: Indica que el archivo `HTML` generado incluir치 todos los recursos necesarios (como `JavaScript` y `CSS`)  en 칠l, haciendo que sea autocontenido y no dependiente de recursos externos.  
- `mapshot`: Captura una imagen est치tica del mapa interactivo, 칰til para generar vistas previas o miniaturas sin necesidad de interacci칩n directa.    

Es importante que el uso combinado de saveWidget y mapshot en el mismo contexto podr칤a no ser necesario. Normalmente, se elige uno u otro seg칰n la necesidad espec칤fica: guardar el mapa interactivo para ser utilizado en un sitio web (saveWidget) o capturar una imagen est치tica para prop칩sitos de visualizaci칩n o impresi칩n (mapshot).    
 
```{r}
#saveRDS(map,  paste0(here::here(), "/Output/map_2020.RDS"))
saveWidget(map,  paste0(here::here(), "/img/map_2010_2020.html"), selfcontained = TRUE)
map <- map %>% 
        mapshot(url = paste0(here::here(), "/map_2010_2020.html"))
```


# Librer칤as

**Librer칤as que se usaron en el trabajo**

```{r, echo = FALSE, eval = TRUE}
sesion_info <- devtools::session_info()
knitr::kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
 kableExtra::kable_classic(full_width = TRUE, html_font = 'Montserrat Medium', font_size = 10) 
```


<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Licence" style="border-width:0"/></a><br />This work by [**Diana Villasana Ocampo**]{xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"} is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.  